#version 450

// ========= STRUCTS =========
// Definições que espelham as structs do seu código C++

struct Camera {
    vec3 position;
    vec3 view_u;
    vec3 view_v;
    vec3 pixel_00_loc;
};

struct Material {
    vec3 color;
    vec3 ambient;
    vec3 specular;
    float shininess;
};

struct SceneObject {
    vec3 center;
    float radius;
    int type;
    int material_index;
};

// ========= BUFFERS (Bindings) =========
// Conecta o shader aos buffers que você configurou no C++

// binding 0: Buffer de saída para escrever a imagem final
layout(set = 0, binding = 0) buffer OutputBuffer {
    vec4 imageData[];
} outBuffer;

// binding 1: Buffer uniforme com os dados da câmera
layout(set = 0, binding = 1) uniform UBO {
    Camera camera;
} ubo;

layout(set = 0, binding = 2) readonly buffer ObjectBuffer { SceneObject objects[]; } objectBuffer;
layout(set = 0, binding = 3) readonly buffer MaterialBuffer { Material materials[]; } materialBuffer;


// ========= FUNÇÃO DE INTERSEÇÃO =========
// Lógica de Ray-Tracing para uma única esfera.
// Retorna a distância 't' do acerto, ou um número grande se não acertar.
float hit_sphere(in SceneObject s, in vec3 ray_origin, in vec3 ray_direction) {
    vec3 oc = ray_origin - s.center;
    float a = dot(ray_direction, ray_direction);
    float half_b = dot(oc, ray_direction);
    float c = dot(oc, oc) - s.radius * s.radius;
    float discriminant = half_b * half_b - a * c;

    if (discriminant < 0.0) {
        return 100000.0; // Retorna um valor grande para "sem acerto"
    } else {
        // Retorna a raiz mais próxima que esteja na frente da câmera
        float t = (-half_b - sqrt(discriminant)) / a;
        if (t > 0.001) {
            return t;
        }
        t = (-half_b + sqrt(discriminant)) / a;
        if (t > 0.001) {
            return t;
        }
    }
    return 100000.0;
}


// ========= PROGRAMA PRINCIPAL =========
// Define o tamanho do grupo de trabalho da GPU
layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

void main() {
    uvec2 pixelCoords = gl_GlobalInvocationID.xy;
    if (pixelCoords.x >= 800 || pixelCoords.y >= 600) {
        return;
    }

    // Calcula o índice do pixel que este shader específico está processando
    uint index = gl_GlobalInvocationID.y * (gl_NumWorkGroups.x * gl_WorkGroupSize.x) + gl_GlobalInvocationID.x;

    // Calcula as coordenadas (u,v) do centro do pixel
    float u = float(gl_GlobalInvocationID.x + 0.5);
    float v = float(gl_GlobalInvocationID.y + 0.5);

    // Calcula a origem e a direção do raio usando os dados da câmera
    vec3 ray_origin = ubo.camera.position;
    vec3 target_point = ubo.camera.pixel_00_loc + (ubo.camera.view_u * u) - (ubo.camera.view_v * v);
    vec3 ray_direction = normalize(target_point - ray_origin);

    // --- LÓGICA DO RAY TRACING ---
    vec3 final_color = vec3(0.5, 0.7, 1.0); // Cor do céu (padrão)
    float closest_hit = 100000.0;
    int hit_material_index = -1;
    vec3 hit_normal;


    // Itera por todas as esferas no buffer
    for (int i = 0; i < objectBuffer.objects.length(); i++) {
        if (objectBuffer.objects[i].type == 0) { // Sphere
            float t = hit_sphere(objectBuffer.objects[i], ray_origin, ray_direction);

            // Se encontramos um acerto mais próximo do que os anteriores...
            if (t < closest_hit) {
                closest_hit = t;
                hit_material_index = objectBuffer.objects[i].material_index;
                vec3 hit_point = ray_origin + t * ray_direction;
                hit_normal = normalize(hit_point - objectBuffer.objects[i].center);
            }
        }
    }

    if (hit_material_index > -1) {
        final_color = materialBuffer.materials[hit_material_index].color;
    }

    // Escreve a cor final no buffer de saída
    outBuffer.imageData[index] = vec4(final_color, 1.0);
}